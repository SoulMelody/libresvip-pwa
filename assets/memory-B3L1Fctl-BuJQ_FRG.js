import{c as u,e as p}from"./es6--XPcqeHG-DimEyOPk.js";import"./index-DMaTKBbC.js";const{File:r,Blob:_,DOMException:s}=u,{INVALID:y,GONE:n,MISMATCH:w,MOD_ERR:z,SYNTAX:a,SECURITY:I,DISALLOWED:m}=p;class b{constructor(e,t){this.fileHandle=e,this.file=t,this.size=t.size,this.position=0}write(e){let t=this.file;if(typeof e=="object"){if(e.type==="write"){if(Number.isInteger(e.position)&&e.position>=0&&(this.position=e.position,this.size<e.position&&(this.file=new r([this.file,new ArrayBuffer(e.position-this.size)],this.file.name,this.file))),!("data"in e))throw new s(...a("write requires a data argument"));e=e.data}else if(e.type==="seek")if(Number.isInteger(e.position)&&e.position>=0){if(this.size<e.position)throw new s(...y);this.position=e.position;return}else throw new s(...a("seek requires a position argument"));else if(e.type==="truncate")if(Number.isInteger(e.size)&&e.size>=0){t=e.size<this.size?new r([t.slice(0,e.size)],t.name,t):new r([t,new Uint8Array(e.size-this.size)],t.name),this.size=t.size,this.position>t.size&&(this.position=t.size),this.file=t;return}else throw new s(...a("truncate requires a size argument"))}e=new _([e]);let i=this.file;const o=i.slice(0,this.position),d=i.slice(this.position+e.size);let h=this.position-o.size;h<0&&(h=0),i=new r([o,new Uint8Array(h),e,d],i.name),this.size=i.size,this.position+=e.size,this.file=i}close(){if(this.fileHandle._deleted)throw new s(...n);this.fileHandle._file=this.file,this.file=this.position=this.size=null,this.fileHandle.onclose&&this.fileHandle.onclose(this.fileHandle)}}class l{constructor(e="",t=new r([],e),i=!0){this._file=t,this.name=e,this.kind="file",this._deleted=!1,this.writable=i,this.readable=!0}async getFile(){if(this._deleted)throw new s(...n);return this._file}async createWritable(e){if(!this.writable)throw new s(...m);if(this._deleted)throw new s(...n);const t=e.keepExistingData?await this.getFile():new r([],this.name);return new b(this,t)}async isSameEntry(e){return this===e}async _destroy(){this._deleted=!0,this._file=null}}class f{constructor(e,t=!0){this.name=e,this.kind="directory",this._deleted=!1,this._entries={},this.writable=t,this.readable=!0}async*entries(){if(this._deleted)throw new s(...n);yield*Object.entries(this._entries)}async isSameEntry(e){return this===e}async getDirectoryHandle(e,t){if(this._deleted)throw new s(...n);const i=this._entries[e];if(i){if(i instanceof l)throw new s(...w);return i}else{if(t.create)return this._entries[e]=new f(e);throw new s(...n)}}async getFileHandle(e,t){const i=this._entries[e],o=i instanceof l;if(i&&o)return i;if(i&&!o)throw new s(...w);if(!i&&!t.create)throw new s(...n);if(!i&&t.create)return this._entries[e]=new l(e)}async removeEntry(e,t){const i=this._entries[e];if(!i)throw new s(...n);await i._destroy(t.recursive),delete this._entries[e]}async _destroy(e){for(let t of Object.values(this._entries)){if(!e)throw new s(...z);await t._destroy(e)}this._entries={},this._deleted=!0}}const g=new f(""),k=()=>g;export{l as FileHandle,f as FolderHandle,b as Sink,k as default};
